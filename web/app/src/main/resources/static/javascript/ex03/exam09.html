<!DOCTYPE html><!--211216-->
<html>
<head>
<meta charset="UTF-8">
<title>ex03</title>
</head>
<body>
<h1>함수 - 아규먼트로 함수를 전달하기</h1>
<script>
"use strict"
// 함수는 객체이기 때문에 주소를 주고 받을 수 있다.
//

// 함수 객체를 아규먼트로 넘길 때
// 보통 파라미터 이름을 fn 또는 cb(callback)로 한다.
// "콜백(callback) 함수"
// => 직접 호출하는 것이 아니라 다른 함수에게 파라미터 값으로 전달하여
//    호출되도록 만드는 함수.
//
function play(cb) { //함수주면 함수를 호출해줄게
    console.log("계산 결과 =", cb(100, 200));  // 콜백 함수
    // 함수 주소를 받은 play는 파라미터 값과 함께 해당 함수를 호출한다.
    // 그리고 호출한 함수가 리턴한 값을 받아 출력한다.
}

function plus(a, b) {return a + b;}
function minus(a, b) {return a - b;}

play(plus); // 호출될 함수를 파라미터로 넘긴다. 그러면 play()가 호출해 줄 것이다.
play(minus); //실제로는 함수의 주소를 넘기는 것이다.

function Calculator(cb) {
//2. 주소 값을 넘겨 받은 Calculator는 파라미터 값과 함께 해당 함수를 호출한다
  console.log("계산결과 =", cb(100, 200));
  // 4. 리턴 받은 값을 출력한다.
}

function Multiplication(a, b) {return a + b;} //3. 호출 받은 Multiplication이 넘겨 받은 파라미터로 결과를 리턴한다
function Division(a, b) {return a / b;}

Calculator(Multiplication); //﻿1. Calculator에게 Multiplication 함수의 주소 값을 넘겨 준다
Calculator(Division);

// 생각해 볼 문제?
// 다음은 콜백 메서드인가? 아닌가?
function play2(v1, v2, op) {
	if (op == "+") {
		console.log(plus(v1, v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
	} else if (op == "-") {
		console.log(minus(v1, v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
	} else {
		console.log("해당 연산을 지원하지 않습니다.");
	}
}

play2(100, 200, "+");
play2(100, 200, "-");

</script>

</body>
</html>
